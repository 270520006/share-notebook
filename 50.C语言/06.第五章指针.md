---
title: 第五章 指针
date: 2021-05-11 14:30:00
permalink: /c/note5/
author: 
    name: eric
    href: https://wfmiss.cn
---
# 第五章 指针【C语言的灵魂】

## 1. 指针及指针变量【概念、定义】

定义指针变量：`类型名称 *指针变量名;`

**在定义指针变量时要注意：**

1. 指针变量前面的“`*`”表示该变量为指针型变量。
2. 在定义指针变量时必须**指定基类型。**指针的基类型用来定义此指针变量可以指向的变量的类型。一个变量的指针的含义包括两个方面，一是存储单元编号表示的纯地址，一是它指向的存储单元的数据类型（如int、char、float等）。
3. 指向整型数据的指针类型表示为“`int*`”，读作**“指向int的指针”**或简称**“int指针”**。【`int*,float*,char*`，是三种不同的类型，不能混淆】
4. 指针变量中只能存放地址（指针），不要将一个整数赋给指针变量。
   - 如:`*pointer_1=100;      //pointer_1是指针变量，100是整数，不合法`

如果需要取出某个变量的地址，可以使用取址运算符`&`:

例如：

```c
char *pa = &a;
int *pb = &b;
```

如果需要访问指针变量指向的数据类型，可以使用取值运算符`*`:

例如：

```c
printf("%c,%d\n",*pa,*pb);
```

*******

访问地址里的值的两种方式：

直接访问：即按变量名进行的访问。

间接访问：即通过指针变量进行的访问。

**注意**：避免访问未初始化的指针。【因为未初始化的指针指向的地址是随机的，未初始化就使用是非常危险的！！！】

例如：【以下示例为**错误的**】

```c
#include <stdio.h>
main(){
	int  *a;
    *a = 123;
}
```

**指针与指针变量**

如果有一个**变量**专门来存放另一变量的**地址（即指针）**，则称它为**“指针变量”**。

指针变量就是地址变量，用来存放地址，**指针变量的值就是地址（即指针）。**

**注意：**区分 “指针” 和 “指针变量” 这两个概念。**指针就是一个地址，而指针变量是存放地址值的变量。**

## 2. 引用指针变量

在引用指针变量时，可能有3种情况：

- 给指针变量赋值。
  - 如：`p = &a;		//把 a 的地址赋给指针变量 p `。
  - 指针变量p的值是变量a的地址，p指向a。
- 引用指针变量指向的变量。
  - 如果已经执行`p=&a;`，即指针变量p指向了整型变量a，则`printf("%d",*p);`
  - 其作用是以整数形式输出变量p指向的变量的值，即变量a的值。
- 引用指针变量的值。
  - 如：`printf("%o",p);`
  - 其作用是以八进制整数输出指针变量的值，如果p指向变量a，就是输出了a的地址，即&a。

**注意：要熟练掌握两个有关运算符。**

- `&` 取地址运算符。&a是变量a的地址。
- `*` 指针运算符（或称“间接访问”运算符），`*p`代表指针变量p指向的对象。

*****

**指针变量作为函数参数**

函数的参数不仅可以是整数型、浮点型、字符型等数据，还可以是指针类型。它的作用是将一个变量的地址传送到另一个函数中。

注意：不能企图通过改变指针形参的值而使指针实参的值改变。

*****

## 3. 通过指针引用数组

指针变量既然可以指向变量，当然也可以指向数组元素（把某一元素的地址放到一个指针变量中）。所谓数组元素的指针就是数组元素的地址。

将数组元素地址赋值给指针变量，如：

```c
int a[10]={1,3,5,7,9,11,13,15,17,19};//定义a为包含10个整型数据的数组
int *P;								 //定义p为指向整型变量的指针变量
p = &a[0];							 //把a[0]元素的地址赋给指针变量p
```

下标法赋值：

`指针变量 = &数组名[数值];` 将下表为 `数组名[数值]` 的元素地址，赋值给 `指针变量`。

不加标赋值：

`指针变量 =  数组名;`将数组的首元素【即`数组名[0]`】地址赋值给`指针变量`。

下面两个语句等价：

```c
int *p;
 p = &a[0];
-------------------
int *p;
p = a;
```

**引用数组元时指针的运算**

在指针已指向一个数组元素时，可以对指针进行以下运算：

- 加一个整数（用`+或+=`），如`p+1`；
- 减一个整数（用`-或-=`），如`p-1`；
- 自加运算，如：`p++;  ++p;`
- 自减运算，如：`p--; --p;`

两指针相减，如：`p1-p2`（只有p1和p2都指向同一数组中的元素时才有意义）。

分别说明如下：

- 如果指针变量p已指向数组中的一个元素，则p+1指向同一数组中的下一个元素，p-1指向同一数组元素中的上一个元素。
  - 注意：执行p+1时并是将p的值（地址）简单的加1，而是加上一个数组元素所占的字节数。
  - 例如：数组元素是float型，每个元素是float型，每个元素占4个字节，则p+1意味着使p的值（地址）加4个字节，以使它指向下一元素。
- 如果p的初值为`&a[0]`,则表示`p+i`和`a+i`就是数组元素`a[i]`的地址。
- `*(p+i)`或`*(a+i)`是`p+i`或`a+i`所指向的数组元素，即`a[i]`。
  - 说明：`[]`实际上是变址运算符，即将`a[i]`按`a+i`计算然后找出此地址单元中的地址。
- 如果指针变量`p1`和`p2`都指向同一组数组中的元素，如执行`p2-p1`,结果是`p2-p1`的值（两个地址之差）除以数组元素的的长度。
  - 注意：两个地址不能相加，如`p1+p2`是无实际意义的。

*******

**通过指针引用数组元素**

引用一个数组元素，可以用下面两种方法：

- 下标法：如`a[i]`形式；
- 指针法：如`*(a+i)`或`*(p+i)`。其中 `a` 是数组名，`p` 是指向数组元素的指针变量，其初值`p=a`。

指向数组元素的指针变量也可以带下标，如`p[i]`。

`++` 和 `*` 同优先级，结合方向为自左向右。

`*(p++)与*(++p)`，作用不相同。

- `*(p++)`:是先取`*p`的值，然后使`p+1`。
- `*(++p)`:是先`p+1`，然后再取`*p`的值。

`++(*p)`：表示`p`所指向的元素值加1。

`--(*p)`：表示`p`所指向的元素值减1。

所以：

- `*(++p)`相当与`a[++i]`，先使p自加，再进行`*`运算。
- `*(--p)`相当与`a[--i]`，先使p自减，再进行`*`运算。

**用数组名做函数参数**

数组名做函数参数方法定义一般形式为：

```C
返回值类型 方法名(参数类型 数组名[],参数列表……){
    方法体;
    返回值;
}
```

指针做函数参数定义一般形式为：

```C
返回值类型 方法名(参数类型 *数组名,参数列表……){	//这里的 “*数组名” 表示数组的首元素地址 “数组名[0]”
    方法体;
    返回值;
}
```

两种定义方法等价。

`*数组名`等价于`数组名[0]`。

**注意：**数组名做方法参数时，传递的是数组首元素的地址，而非元素值。

常用这种方法通过调用一个函数来改变实参数组的值。

*以表变量名和数组名作为函数参数的比较*

| 参数类型                     | 变量名               | 数组名             |
| ---------------------------- | -------------------- | ------------------ |
| 要求的形参类型               | 变量名               | 数组名或指针       |
| 传递参数                     | 变量的值             | 实参数组首元素地址 |
| 通过函数调用能否改变实参的值 | 不能改变实参变量的值 | 能改变实参数组的值 |

**注意：**实参数组名代表一个固定的地址，或者说是指针常量，但形参数组名并不是一个固定的地址，而是按指针变量处理。

在函数调用进行虚实结合后，形参的值就是实参数组首元素的地址。在函数执行期间，它还可以再被赋值。

**归纳分析：**如果有一个实参数组，想要在函数中改变此数组中的元素的值，实参与形参的对应关系有以下4种情况。

- 形参和实参都用数组名。
  - 例如：

```c
int main(){
    int a[10];
    ...
    f(a,10);
    ...
}
int f(int x[],int n){
    ...
}
//由于形参数组名x接收了实参数组首元素a[0]的地址值，因此可以认为在函数调用期间，形参数组与实参数组共用一段内存单元。
```

- 实参用数组名，形参用指针变量。
  - 例如：

```c
int main(){
    int a[10];
    ...
    f(a,10);
    ...
}
void f(int *x,int n){
    ...
}
//实参a为数组名，形参数组x为int * 型的指针变量，调用函数开始后，形参x指向a[0],即x=&a[0]。通过x的值改变，可以指向a数组的任一元素。
```

- 实参形参都用指针变量。
  - 例如：

``` c
int main(){
    int a[10], *p = a;
    ...
    f(p,10);
    ...
}
void f(int *x,int n){
    ...
}
//实参p和形参x都是int * 型的指针变量。先使实参指针变量p指向数组a[0]，p的值是&a[0]。然后将p的值传给指针变量x，x的初始值也是&a[0],通过x值的改变可以使x指向数组元素a的任一元素。
```

- 实参为指针变量，形参为数组名。
  - 例如：

```c
int main(){
    int a[10], *p = a;
    ...
    f(p,10);
    ...
}
void f(int x[],int n){
    ...
}
//实参p为指针变量，它指向a[0]。形参为数组名x，编译系统把x作为指针变量处理，今将a[0]的地址传给形参x，使x也指向a[0]。也可以理解为形参数组x和a数组共用同一段内存单元。在函数执行过程中可以使x[i]的值发生变化，而x[i]就是a[i]。
```

**注意：**如果使用指针变量作实参，必须先使指针变量有确定值，指向一个以定义的对象。

以上4种方法，实质上都是地址的传递。其中（3）、（4）两种只是形式上的不同，实际上形参都是使用指针变量。

**通过指针引用多维数组**

指针引用多维数组：除了表示取元素之外，还可以表示取哪一维

对于二维数组：
1、

<img src="https://cdn.jsdelivr.net/gh/wfmiss/pictures/C_language/20210514161544.png" style="zoom:150%;" />

`a`是一个行指针。指向一个有四个元素的数组，占16个字节
`&a`是一个指向二维数组的指针，二维数组有12个元素，占48个字节
`*a`是一个指向int类型数据的指针。

2、
`a[i][j]`等价于`*((a+i)+j)`，` &a[i][j]`等价于`(a+i)+j`
`a[i]`等价于`*(a+i)`，` &a[i]`

<img src="https://cdn.jsdelivr.net/gh/wfmiss/pictures/C_language/20210514161543.png" style="zoom:150%;" />

3、 二维数组名是指向行的，它不能对如下说明的指针变量p直接赋值：

```c
int a[3][4]={{10,11,12,13},{20,21,22,23},{30,31,32,33}},*p;
```


其原因就是p与a的对象性质不同，或者说二者不是同一级指针。C语言可以通过定义行数组指针的方法，使得一个指针变量与二维数组名具有相同的性质。

行数组指针的定义方法如下：
`数据类型 (*指针变量名)[二维数组列数];`

例如，对上述a数组，行数组指针定义如下：
`int (p)[4];`它表示，数组p有4个int型元素，分别为`(*p)[0]、(*p)[1]、(*p)[2]、(*p)[3] `，亦即p指向的是有4个int型元素的一维数组，即p为行指针

此时，可用如下方式对指针p赋值：
`p=a;`

*****
**指针访问三维数组**
数组与指针关系密切，数组元素除了可以使用下标来访问，还可用指针形式表示。数组元素可以很方便地用数组名常指针来表示，以3维int型数组A举例，其中的元素A[i][j][k]可用下述形式表示：

（1）`*(A[i][j]+k)`
`A[i][j]`是int型指针，其值为`&A[i][j][0]`，因此，`A[i][j][k]`可表述为`*(A[i][j]+k)`。
（2）`*(*(A[i]+j)+k)`
和第一种形式比较，不难发现`A[i][j]= *(A[i]+j)`，`A[i]`是二级指针，其值为&`A[i][0]`。
（3）`*(*(*(A+i)+j)+k)`
将第2种形式的A[i]替换成了`*(A+i)`，此处A是三级指针，其值为`&A[0]`。
此处以3维数组举例，还可进一步推广到更高维的情况。

******
**指针数组**
指针也可作为数组中的元素，将一个个指针用数组形式组织起来，就构成了指针数组。

一个数组，若其元素均为指针类型数据，称为指针数组，也就是说，指针数组中的每一个元素都存放一个地址，相当于一个指针变量。

定义一维指针数组的一般形式为:
```c
类型名 *数组名[数组长度];
int *p[4];
```

*****

**用指向数组的指针作函数参数**

一维数组名可以做函数参数，多维数组名可以做函数参数。用指针变量作形参，以接受实参数组名传递过来的地址。

可以有两种方法：

- 用指向变量的指针变量。
- 用指向一维数组的指针变量。

## 4. 通过指针引用字符串

字符串的应用方式：

- 用字符数组存放一个字符串，可以通过数组名和下标引用字符串中的一个字符，也可以通过数组名和格式声明`%s`输出该字符串。

```c
#include <stdio.h>
main(){
    char *string;
    string="I love you";
    printf("%s\n",string);

    char string2[]="I love you";
    printf("%s\n",string2);
    
    char string3[]={"I love you"};
    printf("%s\n",string3);
}
//三种定义形式输出结果一样
```

- 用指针变量访问字符串。通过改变指针变量的值使它指向字符串中的不同字符。

**使用字符串指针变量和字符数组的比较**

1. 字符串由若干个元素组成，每个元素中放一个字符，而字符指针变量中存放的是地址（字符串第一个字符的地址），绝不是将字符串放到字符指针变量中。
2. 赋值方式。可以对字符串指针变量赋值，但不能对数组名赋值。
3. 初始化定义。对字符指针变量赋初值：

```c
char *a="I love china!";
//等价于
char *a；
a = "I Love china!";
//而对数组的初始化：
char str[14]="I love china!";
//不等价于
char str[14];
str[]="I love china!";
```

数组可以在定义时对各元素赋初值，但不能用赋值语句对字符串数组中全部元素整体赋值。

4. 存储单元的内容。编译时为字符数组分配若干存储单元，以存放各元素的值，而对字符指针变量，只分配一个存储单元。
   - 如果定义了字符数组，但未能对它赋值，这时数组中的元素的值是不可预料的。可以引用（如输出）这些值，结果显然是无意义的，但不会造成严重的后果，容易发现和更正。
   - 如果定义了字符指针变量，应当及时把字符变量（或字数组元素）的地址赋给它，使它指向一个字符型数据，如果未对它赋予一个地址值，它并未具体指向一个确定的对象。此时如果向该指针变量指向的对象输入数据，可能会出现严重的后果。
5. 指针变量的值是可以改变的，而字符数组名代表一个固定的值（数组首元素的地址），不能改变。
6. 字符数组中各元素的值是可以取代的（可以对它们在赋值），但字指针变量指向的字符串常量中的内容是不可以被取代的（不能对他它们在赋值）。
7. 引用数组元素。对字符数组可以用下标法（用数组名和下标）引用一个数组元素，也可以用地址法引用数组元素。
8. 用指针变量指向一个格式字符串，可以用它代替printf函数中的格式字符串。

```c
char *format;
format = "a=%d,b=%f\n";//使format指向一个字符串
printf(format,a,b);
//这种printf函数称为可变格式输出函数。
```

**字符指针做函数参数**

实参和形参都可以选择字符数组名和字符指针变量，但存在区别：
（1）编译时为字符数组分配若干存储单元，以存放个元素的值，而对字符指针变量，只分配一个存储单元
（2）指针变量的值是可以改变的，而数组名代表一个固定的值（数组首元素的地址），不能改变

```c
char *a="i am a student"
a=a+7;   //合法的

char str[]={"i am a student"};
str=str+7  //非法的
```

（3）字符数组中各元素的值是可以改变的，但字符指针变量指向的字符串常量中的内容是不能改变的

```c
char a[]="house";
char *b="house";
a[2]='r';    //合法  
*(b+2)='r';  //非法 
```

接着，引入一个用字符数组名作为函数参数的例子，实现字符串的复制

```c
#include<stdio.h>
int main(){
    void copy_string(char from[] ,char to[]);
    char a[]="i am a teacher";
    char b[]="you are a student";
    
    copy_string(a,b);  //把a复制到b
    printf("%s\n%s",a,b); 
} 
void copy_string(char from[], char to[]){
    int i=0;
    while(from[i]!='\0'){
        to[i]=from[i]; i++;
    }
    to[i]='\0';
}
```

## 5. 指向函数的指针

函数名就是函数的指针，它代表函数的起始地址。

**定义和使用指向函数的指针变量**

定义指向函数的指针变量的一般形式为：

`类型名 (*指针变量名)(函数参数列表)`

这里的 “类型名” 是指函数的返回类型。

**说明：**

1. 定义指向函数的指针变量，并不意味着这个指针变量可以指向任何函数，它只能指向在定义时指定的类型的函数。
   - 在程序中把哪一个函数的地址赋给它，它就指向哪一个函数。在一个程序运行中，一个指针变量可以先后指向同类型的不同函数。
2. 如果要用指针调用函数，必须先使用指针变量指向该函数。
   - 如：`指针变量名 = 函数名 ;`这样就把 “函数名” 的入口地址赋给了指针变量 “指针变量名“ 。
3. 在给函数指针变量赋值时，只须给出函数名而不必给出参数。
4. 用函数指针变量调用函数时，只需将（`*指针变量名`）代替函数名即可，在（`*指针变量名）之后的括号中根据需要写上实参。
5. 对指向函数的指针变量不能进行算数运算，如`p+n,p++,p--`等运算是无意义的。
6. 用函数名调用函数，只能调用所指定的一个函数，而通过指针变量比较灵活，可以根据不同情况先后调用不同的函数。

******

**用指向函数的指针作函数参数**

指向函数的指针变量的一个重要用途是把函数的入口地址作为参数传递到其他函数。

指向函数的指针可以作为函数参数，把函数的入口地址传递给形参，这样就能够在被调用的函数中使用实参函数。

它的原理简述如下：

有一个函数（假设函数名为fun），它有两个形参（x1和x2），定义x1和x2为指向函数的指针变量。再调用函数fun时，实参为两个函数名f1和f2，给形参传递的是f1和f2的入口地址。这样在函数fun中就可以调用f1和f2函数了。

例如：

```c
实参函数名       f1				f2
void fun(int (*x1)(int),int (*x2)(int,int))//定义fun函数，形参是指向函数的指针变量
{
    int a,b,i=3,j=5;
    a=(*x1)(i);		//调用f1函数，i是实参
    b=(*x2)(i,j);	//调用f2函数，i、j是实参
}
```

在fun函数中声明形参x1和x2为指向函数的指针变量，x1指向的函数有一个整型形参，x2指向的函数有两个整型实参。函数fun的形参x1和x2（指针变量）在函数fun未被调用时并不占内存单元，也不指向任何函数。在主函数调用fun函数时，把实参函数f1和f2的入口地址传给形参指针变量x1和x2，使x1和x2指向函数f1和f2。这时，在函数fun中，用`*x1`和`*x2`就可以调用函数f1和f2。`(*x1)(i)`就相当于`f1(i)`,`(*x2)(i,j)`就相当于`f2(i,j)`。

## 6. 返回指针值的函数

定义返回指针的函数的原型一般形式为：

```c
类型名 *函数名(参数列表);
```

例如：

```c
int *a(int x,int y);
```

a是函数名，调用它以后能得到一个`int*`型（指向整型数据）的指针，即整型数据的地址。x和y是函数a的形参，为整型。

请注意在`*a`两侧没有括号，在a的两侧分比是`*`运算符和`()`运算符。而`()`优先级高于`*`，因此a先与`()`结合，显然这是函数形式。这个函数前面有一个`*`，表示此函数是指针型函数（函数值是指针）。最前面的`int`表示返回的指针指向整型变量。

## 7. 指针数组和多重指针

定义一维指针数组的一般形式为：

```c
类型名 *数组名[数组长度];
```

类型名中应包括符号`*`，如`int*`表示指向整数数据的指针类型。

例如：

```c
int *p[4];
```

由于`[]`比`*`优先级高，因此p先与`[4]`结合，形成`p[4]`形式，表示p数组有4个元素。然后再与p前面的`*`结合，`*`表示此数组是指针类型的，每个数组元素（相当于一个指针变量）都指向一个整型变量。

注意一定不要写成：

```c
int (*p)[4];	//这是指向一维数组的指针变量
```

**指向指针数据的指针变量**

定义一个指向指针数据类型的指针变量：

```c
char **p;
```

p的前面有两个`*`号。`*`运算符的结合性是从右到作，因此`**p`相当于`*(*p)`，显然`*p`是指针变量的定义形式。如果没有最前面的`*`,那就是定义了一个指向字符数据的指针变量。现在它前面又有一个`*`号，即`char**p`。可以把它分成两部分看，即：`char*`和`( *p)`,后面的`( *p)`表示`P`是指针变量,前面的`char*`表示`p`指向的是`char*`型的数据。也就是说,`P`指向一个字符指针变量（这个字符指针变量指向一个字符型数据）。

例如：使用指向指针数据的指针变量。

```C
#include<stdio.h>
main(){
    char *name={"Follw me","BASIC","Great Wall","FORTRAN","Computer design"};
    char **p;
    int i;
    for(i=0;i<5;i++){
        p=name+i;
        printf("%s\n",**p);
    }
}
```

**指针数组作main函数的形参**

main函数的第1行一般写成以下形式：

`int main()`或`int main(void)`

括号中是空的或有“void”，表示main函数没有参数，调用main函数时不必给出实参。

这是一般程序常采用的形式。实际上，在某些情况下，main函数可以有参数，即：

```c
int main(int arge,char * argv[])
```

其中，`argc`和`argv`就是main函数的形参，它们是程序的“命令行参数”。

`arge` ( `argument count`的缩写,意思是参数个数) ，argv`(`argument vector` 缩写,意思是参数向量),它是一个*char指针数组，数组中每一个元素（其值为指针）指向命令行中的-个字符串的首字符。

**注意：**如果用带参数的main函数，其第一个形参必须是int 型,用来接收形参个数，第二个形参必须是字符指针数组，用来接收从操作系统命令行传来的字符串中首字符的地址。通常main函数和其他函数组成一个文件模块，有一个文件名。对这个文件进行编译和连接，得到可执行文件(后缀为.exe)。用户执行这个可执行文件，操作系统就调用main函数，然后由main函数调用其他函数，从而完成程序的功能。

什么情况下main函数需要参数?main函数的形参是从哪里传递给它们的呢？

显然形参的值不可能在程序中得到。main函数是操作系统调用的，实参只能由操作系统给出。在操作命令状态下，实参是和执行文件的命令一起给出的。例如在DOS,UNIX或Linux等系统的操作命令状态下，在命令行中包括了命令名和需要传给main函数的参数。

命令行的一般形式为：

```txt
命令名 参数1 参数2 ... 参数n
```

命令名和各参数之间用空格分隔。

## 8. 动态内存分配与指向它的指针变量

对内存动态分配是通过系统提供的函数库来实现的，主要有 molloc ，calloc ，free ，realloc 这4个函数。

- 用**malloc**函数开辟动态存储区：

其函数原型为：

```c
void * malloc(unsigned int size);
```

其作用是在内存的动态存储区中分配一个长度为size 的连续空间。形参size的类型定为无符号整型(不允许为负数)。

此函数的值(即“返回值")是所分配区域的第一个字节的地址，或者说,此函数是一个指针型函数，返回的指针指向该分配域的第一个字节。如:

```c
malloc( 100);		//开辟100字节的临时分配域.函数值为其第1个字节的地址
```

注意指针的基类型为void，即不指向任何类型的数据，只提供一个纯地址。

如果此函数未能成功地执行(例如内存空间不足)，则返回空指针(NULL)。

- 用**calloc**函数开辟动态存储区：

其函数原型为：

```c
void * calloc(unsigned n,unsigned size);
```

其作用是在内存的动态存储区中分配n个长度为size 的连续空间,这个空间一般比较大，足以保存一个数组。

用calloc函数可以为一维数组开辟动态存储空间，n为数组元素个数，每个元素长度为size。这就是动态数组。函数返回指向所分配域的第一个字节的指针；如果分配不成功，返回NULL。

如:

```c
p= calloc(50.4);		//开辟50X4个字节的临时分配域,把首地址赋给指针变量p
```

- 用**realloc**函数重新分配动态存储区

其函数原型为：

```c
void * realloc(void * p,unsigned int size);
```

如果已经通过 malloc 函数或 calloc 函数获得了动态空间，想改变其大小，可以用 recalloc 函数重新分配。

用realloc函数将p所指向的动态空间的大小改变为size。p的值不变。如果重分配不成功,返回NULL。

如：

```c
realloc(p,50);		//将p所指向的已分配的动态空间改为50字节
```

- 用free函数释放动态存储区

其函数原型为：

```c
void free(void * p);
```

其作用是释放指针变量p所指向的动态空间，使这部分空间能重新被其他变量使用。p应是最近一次调用calloc或malloc函数时得到的函数返回值。

如：

```c
free(p);		//释放指针变量p所指向的已分配的动态空间
```

free函数无返回值。

**注意：**以上4个函数的声明在`stdlib. h`头文件中,在用到这些函数时应当用`“# include<stdlib.h>”`指令把`stdlib.h`头文件包含到程序文件中。

**void指针类型**

C99允许使用基类型为void的指针类型。可以定义一个基类型为void的指针变量（即`void*`型变量），它不指向任何类型的数据。请注意：不要把 “指向void类型” 理解为能指向 “任何的类型” 的数据，而应理解为 “指向空类型” 或 “不指向确定的类型“ 的数据。在将它的值赋给另一指针变量时由系统对它进行类型转换，使之适合于被赋值的变量的类型。

例如:

```c
int a=3;							//定义a为整型变量

int *p1=&a;	    					//p1指向int型变量

char *p2;							//p2指向char型变量

void *p3;							//p3为无类型指针变量(基类型为void型)

p3=(void*)p1;						//将p1的值转换为void*类型,然后赋值给p3

p2= (char*)p3;						//将p3的值转换为char*类型,然后赋值给p2

printf("%d",* p1);					//合法,输出整型变量a的值

p3= &a; printf("%d",* p3);  		//错误,p3是无指向的,不能指向a
```

这种空类型指针在形式上和其他指针一样，遵循C语言对指针的有关规定，它也有基类型,只是它的基类型是void。

可以这样定义:

```c
void * p;			//定义p是void*型的指针变量
```

`void*`型指针代表“无指向的地址”，这种指针不指向任何类型的数据。不能企图通过它存取数据，**在程序中它只是过渡性的，只有转换为有指向的地址，才能存取数据。**

C 99这样处理,更加规范，更容易理解，概念也更清晰。

现在所用的一些编译系统在进行地址赋值时，会自动进行类型转换。

例如：

```c
int * pt;
pt= (int*)mcaloc(100);			//mcaloc(100)是void *型，把它转换为int*型
可以简化为
pt= mcaloc(100);				//自动进行类型转换
```

赋值时，系统会先把`mcaloc(100)`转换为的`pt`的类型，即`(int* )`型，然后赋给`pt`,这样`pt`就指向存储区的首字节，在其指向的存储单元中可以存放整型数据。

## 9. 有关指针的小结

(1)首先要准确理解指针的含义。“指针”是C语言中一个形象化的名词,形象地表示“指向”的关系，其在物理上的实现是通过地址来完成的。正如高级语言中的“变量”，在物理上是“命名的存储单元”。Windows中的“文件夹”实际上是“目录”。离开地址就不可能弄清楚什么是指针。明确了“指针就是地址”，就比较容易理解了，许多问题也迎办而解了。

例如：

- `&a`是变量`a`的地址,也可称为变量`a`的指针。

- 指针变量是存放地址的变量,也可以说,指针变量是存放指针的变量。

- 指针变量的值是一个地址,也可以说，指针变量的值是- 一个指针。

- 指针变量也可称为地址变量,它的值是地址。

- `&`是取地址运算符，`&a`是`a`的地址,也可以说，`&`是取指针运算符。`&a`是变量`a`的指针（即指向变量`a`的指针）。

- 数组名是一个地址，是数组首元素的地址，也可以说，数组名是一个指针,是数组首元素的指针。

- 函数名是一个指针（指向函数代码区的首字节），也可以说函数名是一个地址（函数代码区首字节的地址）。

- 函数的实参如果是数组名，传递给形参的是一个地址，也可以说，传递给形参的是一个指针。



(2) 在C语言中，所有的数据都是有类型的，例如常量123并不是数学中的常数123，数学中的123是没有类型的，123和123.0是一样的，而在C语言中，所有数据都要存储在内存的存储单元中，若写成123，则认为是整数，按整型的存储形式存放，如果写成123.0，则认为是单精度实数，按单精度实型的存储形式存放。此外，不同类型数据有不同的运算规则。可以说，C语言中的数据都是“有类型的数据”，或称“带类型的数据”。

对地址而言，也是同样的，它也有类型，首先，它不是一个数值型数据，不是按整型或浮点型方式存储，它是按指针型数据的存储方式存储的（虽然在VisualC++中也为指针变量分配4个字节，但不同于整型数据的存储形式）。指针型存储单元是专门用来存放地址的，指针型数据的存储形式就是地址的存储形式。

其次，它不是一个简单的纯地址，还有一个指向的问题，也就是说它指向的是哪种类型的数据。如果没有这个信息,是无法通过地址存取存储单元中的数据的。所以，一个地址型的数据实际上包含3个信息：

①表示内存编号的纯地址。

②它本身的类型，即指针类型。

③以它为标识的存储单元中存放的是什么类型的数据，即基类型。

例如：已知变量为`a`为`int`型，`&a`为`a`的地址，它就包括以上3个信息，它代表的是一个整型数据的地址，`int`是`&a`的基类型（即它指向的是`int`型的存储单元）。可以把②和③两项合成一项，如 “指向整型数据的指针类型” 或 “基类型为整型的指针类型” ，其类型可以表示为“`int*`”型。这样，对地址数据来说，也可以说包含两个要素：内存编号（纯地址）和类型（指针类型和基类型）。这样的地址是 “带类型的地址” 而不是纯地址。

(3)要区别指针和指针变量。指针就是地址，而指针变量是用来存放地址的变量。有人认为指针是类型名，指针的值是地址。这是不对的。类型是没有值的，只有变量才有值，正确的说法是指针变量的值是一个地址。不要杜撰出 “地址的值” 这样莫须有的名词。地址本身就是一个值。

(4)什么叫 “指向” ？地址就意味着指向，因为通过地址能找到具有该地址的对象。对于指针变量来说，把谁的地址存放在指针变量中，就说此指针变量指向谁。但应注意：并不是任何类型数据的地址都可以存放在同一个指针变量中的，只有与指针变量的基类型相同的数据的地址才能存放在相应的指针变量中。

例如：

```c
int a,*P;	//p是int关型的指针变量,基类型是int型

float b;

p= &a;		//a是int型,合法

p=&b;		//b是float型,类型不匹配
```

既然许多数据对象（如变量数组、字符串和函数等）都在内存中被分配存储空间，就有了地址，也就有了指针。可以定义一些指针变量，分别存放这些数据对象的地址，即指向这些对象。`void*`指针是一种特殊的指针，不指向任何类型的数据。如果需要用此地址指向某类型的数据，应先对地址进行类型转换。可以在程序中进行显式的类型转换，也可以由编译系统自动进行隐式转换。无论用哪种转换，读者必须了解要进行类型转换。

(5)要深入掌握在对数组的操作中正确地使用指针，搞清楚指针的指向。一维数组名代表数组首元素的地址，如：

```c
int *p,a[10];
p=a;
```

p是指向`int`型类型的指针变量，显然，p只能指向数组中的元素（`int`型变量），而不是指向整个数组。在进行赋值时一定要先确定赋值号两侧的类型是否相同，是否允许赋值。

对"`p=a;`" ，准确地说应该是： p指向a数组的首元素，在不引起误解的情况下，有时也简称为：p指向a数组，但读者对此应有准确的理解。同理，p 指向字符串，也应理解为p指向字符串中的首字符。

(6)有关指针变量的归纳比较

指针变量的类型及含义

| 变量定义       | 类型表示    | 含义                                                      |
| -------------- | ----------- | --------------------------------------------------------- |
| `int i;`       | `int`       | 定义整型变量                                              |
| `int *p;`      | `int *`     | 定义p为指向整型数据的指针变量                             |
| `ina a[5];`    | `int [5]`   | 定义整型数组a，它有5个元素                                |
| `int *p[4];`   | `int * [4]` | 定义指针数组p，它由4个指向整型数据的指针元素组成          |
| `int (*p)[4];` | `int(*)[4]` | p为指向包含4个元素的一维数组的指针变量                    |
| `int f();`     | `int ()`    | f为返回整型函数值的函数                                   |
| `int *p();`    | `int * ()`  | p为返回一个指针的函数，该指针指向整型数据                 |
| `int(*p)();`   | `int(*)()`  | p为指向函数的指针，该函数返回一个整型值                   |
| `int **p;`     | `int **`    | p是一个指针变量，它指向一个指向整型数据的指针变量         |
| `void *p;`     | `void *`    | p是一个指针变量，基类型为void（空类型），不指向具体的对象 |

为便于比较,在表中包括了其他一些类型的定义。



(7)指针运算。

①指针变量加（减）一个整数。

例如: `p++`,`p--`,`p+i`,`p-i`,`p+=i`,`p-=i`等均是指针变量加(减)一个整数。

将该指针变量的原值（是一个地址）和它指向的变量所占用的存储单元的字节数相加（减）。

②指针变量赋值。

将一个变量地址赋给一个指针变量。

例如：

```c
p= &a;				//(将变量a的地址赋给p)

P= array;			//(将数组array首元素地址赋给p)

p= &array[i];		//(将数组array 第i个元素的地址赋给p)

p= max;				//(max为已定义的函数.将max的人口地址赋给p)

p1= p2;				//(pl和p2是基类型相同指针变量,将p2的值赋给pl)

```

注意：不应把一个整数赋给指针变量。

③两个指针变量可以相减。

如果两个指针变量都指向同一个数组中的元素，则两个指针变量值之差是两个指针之间的元素个数。

④两个指针变量比较。

若两个指针指向同一个数组的元素，则可以进行比较。指向前面的元素的指针变量“小于”指向后面元素的指针变量。如果p1和p2不指向同一数组则比较无意义。



(8)指针变量可以有空值，即该指针变量不指向任何变量，可以这样表示：`p= NULL;`

其中，NULL是一个符号常量，代表整数0。在`stdio.h`头文件中对NULL进行了定义:`#define NULL 0` 

它使p指向地址为0的单元。系统保证使该单元不作它用(不存放有效数据)。

应注意，p的值为NULL与未对p赋值是两个不同的概念。前者是有值的（值为0），不指向任何变量，后者虽未对p赋值但并不等于p无值,只是它的值是一个无法预料的值，也就是p可能指向一个事先未指定的单元。这种情况是很危险的。因此，在引用指针变量之前应对它赋值。

任何指针变量或地址都可以与NULL作相等或不相等的比较，例如:

```c
if(p==NULL){
    ...
}
```

指针是C语言中很重要的概念，是C的一个重要特色。

使用指针的优点：

①提高程序效率；

②在调用函数时当指针指向的变量的值改变时,这些值能够为主调函数使用，即可以从函数调用得到多个可改变的值；

③可以实现动态存储分配。

同时应该看到，指针使用实在太灵活，对熟练的程序人员来说，可以利用它编写出颇有特色、质量优良的程序，实现许多用其他高级语言难以实现的功能，但也十分容易出错，而且这种错误往往比较隐蔽。指针运用的错误可能会使整个程序遭受破坏，比如由于未对指针变量`p`赋值就向`* p`赋值，就可能破坏了有用的单元的内容。如果使用指针不当，会出现隐蔽的、难以发现和排除的故障。因此，使用指针要十分小心谨慎，要多上机调试程序，以弄清一些细节，并积累经验。

