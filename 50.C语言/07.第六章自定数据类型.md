---
title: 第六章 自定数据类型
date: 2021-05-11 14:30:00
permalink: /c/note6/
author: 
    name: eric
    href: https://wfmiss.cn
---
# 第六章 自定数据类型

## 1. 定义和使用结构体变量

由不同类型数据组成的的组合型的数据结构，它称为结构体（`structre`）。

声明一个结构体类型的一般形式为：

```c
struct 结构体名{
    成员列表
};
```

`struct`是声明结构体类型时必须使用的关键字，不能省略。

注意：结构体类型的名字是由一个关键字`struct`和结构体名组成的。结构体名是由用户指定的，又称“结构体标记”（structure tag），以区别于其他结构体类型。上面的结构体声明中Student 就是结构体名（结构体标记）。

花括号内是该结构体所包括的子项，称为结构体的成员（member）。对各成员都应进行类型声明，即：

```c
类型名 成员名;
```

“成员表列”（member list）也称为“域表”（field list），每一个成员是结构体中的一个域。成员名命名规则与变量名相同。

**说明：**

(1)结构体类型并非只有一种，而是可以设计出许多种结构体类型，还可以根据需要建立结构体类型，各自包含不同的成员。

(2)成员可以属于另一个结构体类型。

例如：

```c
struct Date					//声明一个结构体类型struct Date
{ 
    int month;				//月
    int day;				//日
    int year;				//年
};
struct Student				//声明一个结构体类型struct Student
{ 
    int num;
    char name[20]; 
    char sex;
    int age;
    struct Date birthday; 	//成员birthday属于struct Date类型
    char addr[30];
};
```

**定义结构体类型变量**

1. 先声明结构体类型，再定义该类型的变量

上面已声明了一个结构体类型`struct Student`，可以用它来定义变量。例如:

```c
struct Student student1,student2;
-------------  -------- --------
    |				|		|
结构体类型名		    结构体变量名
```

这种方式是声明类型和定义变量分离，在声明类型后可以随时定义变量，比较灵活。

2. 在声明类型的同时定义变量

例如：

```c
struct Student
{ 
    int num;
    char name[20];
    char sex;
    int age;
    float score;
    char addr[30];
}studentl,student2;
```

它的作用与第一种方法相同，但是在定义struct Student 类型的同时定义两个struct Student类型的变量studentl 和student2。

 这种定义方法的一般形式为：

```c
struct 结构体名{
    成员列表
}变量名表列;
```

声明类型和定义变量放在一起进行，能直接看到结构体的结构，比较直观，在写小程序时用此方式比较方便,但写大程序时，往往要求对类型的声明和对变量的定义分别放在不同的地方，以使程序结构清晰，便于维护，所以一般不多用这种方式。

3. 不指定类型名而直接定义结构体类型变量

其一般形式为：

```c
struct{
    成员表列
}变量名表列;
```

指定了一个无名的结构体类型,它没有名字（不出现结构体名）。显然不能再以此结构体类型去定义其他变量。这种方式用得不多。

**说明：**

(1)结构体类型与结构体变量是不同的概念，不要混淆。只能对变量赋值、存取或运算，而不能对一个类型赋值、存取或运算。在编译时，对类型是不分配空间的,只对变量分配空间。

(2)结构体类型中的成员名可以与程序中的变量名相同，但二者不代表同一对象。 例如，程序中可以另定义一个变量`num`，它与`struct Student `中的`num`是两回事，互不干扰。

(3)对结构体变量中的成员（即“域”），可以单独使用，它的作用与地位相当于普通变量。关于对成员的引用方法见下节。

**结构体变量的初始化和引用**

在定义结构体变量时,可以对它初始化.即赋予初始值。然后可以引用这个变量，例如输出它的成员的值。

(1)在定义结构体变量时可以对它的成员初始化。初始化列表是用花括号括起来的一些常量，这些常量依次赋给结构体变量中的各成员。

注意：是对结构体变量初始化，而不是对结构体类型初始化。

`C99`标准允许对某一成员初始化，如:

```c
struct Student b= {.name=' "Zhang Fang '};//在成员名前有成员运算符"."
```

`“. name”`隐含代表结构体变量`b`中的成员`b.name`。其他未被指定初始化的数值型成员被系统初始化为0，字符型成员被系统初始化为`'\0'`，指针型成员被系统初始化为NULL。

(2)可以引用结构体变量中成员的值，引用方式为：

```c
结构体变量名.成员名
```

`“.”`是成员运算符,它在所有的运算符中优先级最高，因此可以把`b.name`作为一个整体来看待，相当于一个变量。

注意：不能企图通过输出结构体变量名来达到输出结构体变量所有成员的值。

下面用法不正确：

```c
printf("%s\n",b);//企图用结构体变量名输出所有成员的值
```

只能对结构体变量中的各个成员分别进行输人和输出。

(3)如果成员本身又属一个结构体类型，则要用若干个成员运算符，一级一级地找到最低的一级的成员。只能对最低级的成员进行赋值或存取以及运算。如果在结构体`struct Student`类型的成员中包含另一个结构体`struct date`类型的成员`birthday`(为一个结构体) ,则引用成员的方式为：

```c
studentl.num			//(结构体变量studentl中的成员num)
studentl.birthday.month //(结构体变量studentl中的成员birthday中的成员month)
```

不能用`student1. birthday`来访问`student1` 变量中的成员`birthday`, 因为`birthday` 本身是一个结构体成员。

(4)对结构体变量的成员可以像普通变量一样进行各种运算（根据其类型决定可以进行的运算）。

例如:

```c
student2.score = studentl.score;		 //(赋值运算)
sum = student1.score+student2.score;	 //(加法运算) 
studentl.age++;							 //(自加运算)
```

由于`“.”`运算符的优先级最高，因此`studentl.age++`是对(`student1.age`)进行自加运算，而不是先对`age`进行自加运算。

(5)同类的结构体变量可以互相赋值，如：

```c
studentl = student2;//假设student1和student2已定义为同类型的结构体变量
```

(6)可以引用结构体变量成员的地址，也可以引用结构体变量的地址。

例如:

```c
scanf("%d",&student1.num); //(输人studentl. num的值)
printf("%o",&student1);    //(输出结构体变量studentl的起始地址)
```

但不能用以下语句整体读人结构体变量，例如：

```c
scanf("%d,%s,%c,%d,%f,%s\n",&.studentl); 
```

说明：结构体变量的地址主要用作函数参数，传递结构体变量的地址。

## 2. 使用结构体数组

(1)定义结构体数组一般形式是：

```c
struct结构体名{
    成员表列
}数组名[数组长度];
```

先声明一个结构体类型(如`struct Person`)，然后再用此类型定义结构体数组: 

```c
结构体类型 数组名[数组长度];

struct Person{
    char name[20];
    int age;
};

struct Person leader[3]; //leader是结构体数组名
```

(2)对结构体数组初始化的形式是在定义数组的后面加上：

```c
结构体类型 数组名[数组长度]= {初值表列};
```

如：

```c
struct Person leader[3]= {"Li",0,"Zhang",0,"Sun",0}; 
```

## 3. 结构体指针

**指向结构体变量的指针**

指向结构体对象的指针变量既可指向结构体变量，也可指向结构体数组中的元素。指针变量的基类型必须与结构体变量的类型相同。

例如:

```c
struct Student* pt;		//pt可以指向structStudent类型的变量或数组元素
```

说明：为了使用方便和直观，C语言允许把`(*p).num`用`p->num`代替，“`->`”代表 一个箭头，`p->num`表示`p`所指向的结构体变量中的`num`成员。同样，`(*p).name`等价于`p->name`。“`->`”称为指向运算符。

如果`p`指向一个结构体变量`stu`,以下3种用法等价：

①`stu.成员名 (如stu. num);`

②`(*p).成员名 (如(*p).num);`

③`p->成员名 (如p->num)`。

**指向结构体数组的指针**

可以用指针变量指向结构体数组的元素。

例如：有3个学生的信息，放在结构体变量中，要求输出全部学生的信息。

(1)声明结构体类型 `struct Student`，并定义结构体数组，同时初始化；

(2)定义一个指向`struct Student` 类型数据的指针变量p;

(3)使P指向结构体数组的首元素，输出它指向的元素中的有关信息;

(4)使p指向结构体数组的下一个元素，输出它指向的元素中的有关信息;

(5)再使p指向结构体数组的下一个元素，输出它指向的元素中的有关信息。

编写程序:

```c
#include<stdio.h>
struct Student{		//声明结构体类型structStudent
    int num;
    char name[20];
    char sex;
    int age;
};
struct Student stu[3]={{10101,"Li Lin",'M',18},{10102,"Zhang Fang",'M',19},{10104,"Wang Min",'F',20}}; //定 义结构体数组并初始化
int main(){
    struct Student* p;//定义指向structStudent结构体变量的指针变量
    printf(" No. Name           sex age\n");
    for (p= stu;p<stu+3;p++){
        printf(" %5d %-20s %2c %4d\n",p->num,p->name,p->sex,p->age);//输出结果
    }
    return 0;
}
```

![](https://cdn.jsdelivr.net/gh/wfmiss/pictures/C_language/20210516182619.png)



![](https://cdn.jsdelivr.net/gh/wfmiss/pictures/C_language/20210516182618.png)



**注意：**

(1)如果p的初值为`stu`,即指向`stu`的序号为0的元素，p加1后，就指向下一个元素。

例如：

```c
(++p)->num	//先使p自加1，然后得到p指向的元素中的num成员值(10102) 
(p++)->num	//先求得p->num的值(即10101)，然后再使p自加1，指向stu[1]
```

请注意以上二者的不同。

(2)程序定义了p是一个指向`struct Student`类型对象的指针变量,它用来指向一个 `struct Student`类型的对象(p的值是`stu`数组的一个元素(如`stu[0]`或`stu[1]`)的起始地址),不应用来指向`stu`数组元素中的某一成员。

例如，下面的用法是不对的:

```c
p= stu[1].name; //stu[1].name是stu[1]元素中的成员name 的首字符的地址
```

编译时将给出“警告”信息，表示地址的类型不匹配。不要认为反正p是存放地址的，可以将任何地址赋给它。如果一定要将某一成员的地址赋给p，可以用强制类型转换，先将成员的地址转换成p的类型。例如:

```c
p= (struct Student * )stu[0].name;
```

此时，p的值是`stu[0]`元素的name成员的起始地址。可以用“`printf("%s",p);`"输出 `stu[0]`中成员name的值。但是,p仍保持原来的类型。如果执行“`printf("%s',p+1);`,则 会输出`stu[1]`中name 的值。执行`p++`时,p的值的增量是结构体`struct Student`的长度。

**用结构体变量和结构体变量的指针作函数参数**

将一个结构体变量的值传递给另一个函数，有3个方法:

(1)用结构体变量的成员作参数。例如,用`stu[1]. num`或`stu[2].name`作函数实参，将实参值传给形参。用法和用普通变量作实参是一样的，属于“值传递”方式。应当注意实参与形参的类型保持一致。

(2)用结构体变量作实参。用结构体变量作实参时,采取的也是“值传递”的方式，将结构体变量所占的内存单元的内容全部按顺序传递给形参，形参也必须是同类型的结构体变量。在函数调用期间形参也要占用内存单元。这种传递方式在空间和时间上开销较大，如果结构体的规模很大时，开销是很可观的。此外，由于采用值传递方式，如果在执行被调用函数期间改变了形参(也是结构体变量)的值,该值不能返回主调函数，这往往造成使用上的不便。因此一般较少用这种方法。

(3)用指向结构体变量(或数组元素)的指针作实参，将结构体变量(或数组元素)的地址传给形参。

## 4. 用指针处理链表

**什么是链表？**

链表是动态地进行存储分配的一种结构。
作用是为了避免内存的浪费，它是根据需要开辟内存单元设定的。

**单向链表**
由 head 的 next 指向下个节点
头指针：head （整个链表都必须包含head）
结点 ：必须包含两部分（1）用户需要用的实际数据 （2）下一个节点的地址
空指针（表尾）：NULL

**建立链表（利用结构体）**

```c
struct Student
{	int num;
	float score;
	struct Student *next; //next是指针变量，指向下一个结构体的地址
};
```

**输出链表**

```c
void output(struct student *head)  // 定义一个链表输出的函数
{
    struct student *p;  // 定义结构体指针变量p1，用于结点的后移，以实现输出操作
    p = head;  // 将head赋给p1，以实现对该链表的操作
    if (p != NULL) // 建立一个while循环，结束条件是到达尾结点
    do
    {
        printf("%d\n%f\n", p1->num, p1->score);  // 输出结点中的数值部分
        p1 = p1->next;  // 将下一个结点的位置赋给p1
    }while(p != NULL);//当p不是空地址时循环
  
}
```

**注意：**
`malloc()`分配内存后最后记得`free()`释放内存。

可以参看以下博客学习：

https://blog.csdn.net/linwh8/article/details/49648601

*******

## 5. 共同体类型

使几个不同的变量公享同一段内存的结构，称为"共同体"类型结构。

定义共同体类型变量的的一般形式为：

```c
union 共用体名{
    成员列表
}变量列表;
```

例如：

```c
union Data{		//表示不同类型的变量i,ch,f可以存放到同一段存储单元中
    int t;
    char ch;
    float f;
}a,b,c;			//在声明类型同时定义变量
```

也可以将类型声明与变量定义分开：

```c
union Data{ 		//声明共用体类型
    int I;
    char ch;
    float f;
};
union Data a,b,c;	//用共用体类型定义变量
```

即先声明一个`union Data`类型，再将a,b,c定义为`union Data`类型的变量。

当然也可以直接定义共用体变量，例如:

```c
union{ 			//没有定义共用体类型名
	int i;
    char ch;
    float f;
}a,b,c;
```

可以看到，“共用体” 与 “结构体” 的定义形式相似。但它们的含义是不同的。

结构体变量所占内存长度是各成员占的内存长度之和。每个成员分别占有其自己的内存单元。而共用体变量所占的内存长度等于最长的成员的长度。例如，上面定义的“共用 体”变量a，b，c各占4个字节（因为一个float 型变量占4个字节），而不是各占4+1+4=9个字节。

**引用共用体变量的方式**

只有先定义了共同体变量才能引用它，但应注意，不能引用共同变量，而只能引用共同体变量中的成员。

例如：【上面定义的a,b,c共用体】

```c
a.i		//引用共同体变量中的整型变量i
a.ch	//引用共同体变量中的整型变量i
a.f		//引用共同体变量中的整型变量i

//不能只引用共同体变量,下面的引用就是错误的
printf("%d",a);

//正确的写法为
printf("%d",a.i);
printf("%c",a.ch);
printf("%f",a.f);
```

****

**共用体类型数据的特点**

在使用共用体型数据时要主要以下特点：

- 同一个内存段可以用来存放几种不同类型的成员，但在每一瞬时只能存放其中一个成员，而不是同时存放几个。
- 可以对共用体变量初始化，但初始化表中只能有一个常量。
  - 以下用法为错误的：

```c
union Data{
    int i;
    char ch;
    float f;
}a={1,'a',1.5};			//不能初始化3个成员变量，它们占用同一段存储单元
union Data a={16};		//正确，对第1个成员初始化
union Data a={.ch='j'};	//C99允许对指定的一个成员初始化
```

- 共用体变量中起作用的成员是最后一次被赋值的成员，在对共用体变量中的一个成员赋值之后，原变量存储单元中的值就被取代了。
- 共同体变量的地址和它的各成员的地址都是同一地址。
  - 例如：

```c
&a.i,&a.ch,&a.f 		//都是同一地址
```

- 不能对共同变量名赋值，也不能企图引用变量名来得到一个值。
  - 例如，下面这些都是不对的：

```c
i = 1;	//不能对共同体变量赋值，赋给谁？
m = a;	//企图引用共同体变量名以得到一个值赋给整型变量m
**************************************
//C99允许同类型的共同体变量相互赋值。
b = a;	//a和b是同类型的共同变量，合法
```

- 以前的C规定不能把共同体变量作为函数参数，但是可以使用指向共同体变量的指针作函数参数。`C99`允许用共同体变量作为函数参数。
- 共同体类型可以出现在结构体类型定义中，也可以定义共用体数组。反之，结构体也可以出现在共用体类型中，数组也可以作为共用体的成员。

## 6. 使用枚举类型

如果一个变量只有几种可能的值，则可以定义为枚举（enumeration）类型，**所谓 “枚举” 就是指把可能的值一一列举出来，变量的值只限制于列举出来的值的范围内。**

例如:

```c
enum Weekday{sun,mon,tue,wed,thu,fri,sat};
```

以上声明了一个枚举类型`enum Weekday`然后可以用此类型来定义变量。

例如: 

```c
enum Weekday workday,weekend; 
-----------   --------------
    |				|
 枚举类型		  枚举变量
```

`workday`和`weekend`被定义为枚举变量,花括号中的`sun,mon,..，sat`称为枚举元素或枚举常量。它们是用户指定的名字。枚举变量和其他数值型量不同,它们的值只限于花括号中指定的值之一。例如枚举变量`workday`和`weekend`的值只能是`sun`到`sat`之一。

```c
workday= mon; //正确,mon是指定的枚举常量之一

weekend= sun;//正确,sun是指定的枚举常量之一

weekday = monday;//不正确,monday不是指定的枚举常量之一
```

枚举常量是由程序设计者命名的,用什么名字代表什么含义,完全由程序员根据自己的需要而定,并在程序中作相应处理。

也可以不声明有名字的枚举类型,而直接定义枚举变量,例如:

```c
enum{sun,mon,tue,wed,thu,fri,sat} workday,weekend;
```

**声明枚举类型用 `enum` 开头**。

声明枚举类型的一般形式为：

```c
enum [枚举名]{枚举元素……};
```

**说明:**

(1) C编译对枚举类型的枚举元素按常量处理，故称枚举常量。不要因为它们是标识符（有名字）而把它们看作变量，不能对它们赋值。

(2) 每一个枚举元素都代表一个整数,C语言编译按定义时的顺序默认它们的值为`0,1,2,3,4,5...`。在上面的定义中,`sun`的值自动设为0,`mon`的值为1,.,`sat`的值为6。如果有赋值语句:

```c
workday= mon;//相当于
workday= 1;//枚举常量是可以引用和输出的。例如:
printf("%d",workday);//将输出整數1。
```

也可以人为地指定枚举元素的数值，在定义枚举类型时显式地指定，例如：

```c
enum Weekday{sun=7,mon=1,tue,wed,thu,fri,sat} workday,week_end;
```

指定枚举常量`sun`的值为7,`mon`为1,以后顺序加1,`sat`为6。

由于枚举型变量的值是整数，因此`C99`把枚举类型也作为整型数据中的一种，即用户自行定义的整数类型。

(3)枚举元素可以用来作判断比较。例如:

```c
if( workday= = mon).. 
if( workday> sun)... 
```

枚举元素的比较规则是按其在初始化时指定的整数来进行比较的。如果定义时未人为 指定，则按上面的默认规则处理，即第1个枚举元素的值为0，故`mon > sun`，`sat > fri`。

## 7. 用typedef声明新类型名

用typedef指定新的类型名来代替已有的类型名。

有以下两种情况：

1. **简单地用一个新的类型名代替原有的类型名**

例如：

```c
typedef int Integer;	//指定用Integer为类型名,作用与int相同
typedef float Real;		//指定用Real为类型名,作用与float相同
```

指定用`Integer`代表int类型,Real代表float。 这样，以下两行等价：

```c
①int i,j;
float a,b;

②Integer i,j;
Real a,b;
```

2. **命名一个简单的类型名代替复杂的类型表示方法**

从前面已知，除了简单的类型（如int，float等）、C程序中还会用到许多看起来比较复杂的类型，包括结构体类型、共用体类型枚举类型、指针类型、数组类型等，如：

```c
float*[](指针数组)
float( * )[5](指向5个元素的-维数组的指针)
double * (double * )(定义函数，函数的參数是double*型数据,即指向double数据的指针,函数返回值也是指向double数据的指针)
double( * )()(指向函数的指针，函数返回值类型为double)
int * ( * ( * )[10])(void)(指向包含10个元素的一维数组的指针,数组元素的类型为函数指针(函数的地址)，函数没有参数，函数返回值是int 指针)
```

有些类型形式复杂，难以理解，容易写错。C允许程序设计者用一个简单的名字代替复杂的类型形式。

例如：

(1)命名一个新的类型名代表结构体类型:

```c
typedef struct int month;
int year;
} Date;
```

以上声明了一个新类型名Date，代表上面的一个结构体类型。然后可以用新的类型名Date去定义变量，如：

``` c
Date birthday;	//定义结构体类型变量birthday ,不要写成struct Date birthday;
Date* P;		//定义结构体指针变量p.指向此结构体类型数据
```

(2)命名一个新的类型名代表数组类型：

```c
typedef int Num[ 100];	//声明Num为整型数组类型名
Numa;					//定义a为整型数组名,它有100个元素
```

(3)命名一个新的类型名代表指针类型：

```c
typedef char * String;	//声明String为字符指针类型
String p,s[10]; 		//定义p为字符指针变量,s为字符指针数组
```

(4)命名一个新的类型名代表指向函数的指针类型：

```c
typedefint(*Pointer)();	//声明Pointer为指向函数的指针类型,该函数返回整型值
Pointer pl,p2;			//p1,p2为Pointer类型的指针变量
```

归纳起来，声明一个新的类型名的方法是：

```txt
①先按定义变量的方法写出定义体(如:int i;)。
②将变量名换成新类型名(例如:将i换成Count)。
③在最前面加typedef(例如:typedef int Count)。
④然后可以用新类型名去定义变量。
```

简单地说，就是按定义变量的方式，把变量名换上新类型名，并且在最前面加typedef，就声明了新类型名代表原来的类型。

以定义上述的数组类型为例来说明：

```txt
①先按定义数组变量形式书泻: int a[100]。
②将变量名a换成自己命名的类型名:int Num[100]。
③在前面加上typedef,得到typedef int Num[100]。
④用来定义变量:Num a;
相当于定义了:int a[100];
同样,对字符指针类型,也是:
①char * p; 				//定义变量p的方式
②char * String;			//用新类型名String 取代变量名p
③typedef char * String;	//加typedef
④String p;				//用新类型名String定义变量,相当char*p;
```

习惯上，常把用typedef声明的类型名的第1个字母用大写表示，以便与系统提供的标准类型标识符相区别。

