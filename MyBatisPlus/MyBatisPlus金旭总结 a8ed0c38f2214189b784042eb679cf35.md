# MyBatisPlus金旭总结

# MyBatisPlus使用

MyBatisPlus顾名思义是 mybtais的升级版，能够很大程度上提高我们工作效率，减少了我们 80%的业务代码 将我们从乏味 的 CRUD 的苦海中解脱！

## **SpringBoot 2.3.4 整合 mybatis-plus 3.0.5**

mybatisplus 依赖jar 建议： 引入plus了就不建议在引入mybatis

<dependency> <groupId>com.baomidou</groupId> <artifactId>mybatis-plus-boot-starter</artifactId> <version>3.0.5</version> </dependency>

关于它的pom配置 跟Mybatis 相差不大

spring.datasource.username=root

spring.datasource.password=root

spring.datasource.url=jdbc:mysql://localhost:3306/xx?userSSL=true&useUnicode=true&characterEncoding=UTF-8&serverTimezone=UTC

spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver

mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl #开启sql打印输出信息

MyBatisPlus的数据库列驼峰字段转换问题，默认是开启的如果数据库中的列名是 userCode 我们创建的实体类肯定也是 userCode 但是mybatisplus 会以为他是一个驼峰类型属性 user_code 会进行准换，导致我们找不到这个列， 解决方式：

1. 可以在实体类上 属性上添加 @TableFiled(value="userCode") 指定数据库列名

2. mybatis-plus.configuration.map-underscore-to-camel-case=false #关闭驼峰字段转换

## QuickStart

传统方式：

entity-dao[ crud 操作 ]-mapper....

plus开发：

entity-dao[extends BaseMapper<T> ]

**BaseMapper<T> 这是plus提供的公用mapper 通过传入泛型的 T （对应处理的实体类） 然后就会生成它的 各种基本crud 操作。 也要将 dao放入容器中 (@Component) ！！**

### Query

**执行结果**

### 

### Insert

关于 自动生成的 id 号码，以及创建的日期，都是MyBatisPlus提供的一种 生成策略！

**id** ： **默认使用 snowflake 雪花算法** snowflake是Twitter开源的分布式ID生成算法，结果是一个long型的ID。其核心思想是：使用41bit作为毫秒数，10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID），12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 ID），最后还有一个符号位，永远是0。可以保证几乎全球唯一！

其他可选值 ：

**createdDate:**  通过设置进行 自动填充

package org.app.config; import com.baomidou.mybatisplus.core.handlers.MetaObjectHandler; import lombok.extern.slf4j.Slf4j;import org.apache.ibatis.reflection.MetaObject; import org.springframework.stereotype.Component; import java.util.Date ;/** * Created with IntelliJ IDEA. * * @Auther: JinXu * @Date: 2020/10/13/11:48 */ @Slf4j @Component public class MyMetaObjectHandler implements MetaObjectHandler { //插入时的填充策略 @Override public void insertFill(MetaObject metaObject) { log.info("自动进行插入填充"); this.setFieldValByName("createdDate",new Date(),metaObject); } //修改时的填充策略 @Override public void updateFill(MetaObject metaObject) { log.info("自动进行修改填充"); this.setFieldValByName("modifyDate",new Date(),metaObject); } }

### Update

关于update的修改 操作还有 属于 Wrapper 级别的复杂 修改方法！

### 乐观锁

![MyBatisPlus%E9%87%91%E6%97%AD%E6%80%BB%E7%BB%93%20a8ed0c38f2214189b784042eb679cf35/T3QK0P1PV_7(2_4ALZ7.png](MyBatisPlus%E9%87%91%E6%97%AD%E6%80%BB%E7%BB%93%20a8ed0c38f2214189b784042eb679cf35/T3QK0P1PV_7(2_4ALZ7.png)

MyBatisPlus的锁 分为两类 ：

乐观锁： 非常乐观觉得不会出现问题，只有等出现问题了才会去上锁执行操作！

悲观锁： 非常悲观不管做什么都觉得会出现问题，所以对任何操作都会上锁后再去执行，但是性能极低！

MyBatisPlus乐观锁的实现思路：

在数据库和实体类增加 version 字段 （**要有默认值为1**）在进行修改操作时会取出 version 的值进行对比是否是 修改前的版本值 （因为数据的每一次修改 version 都会+1）如果是执行成功否则 执行失败！

**实体类上锁**

**注册乐观锁组件**

**进行测试 并解释流程**

### Delete

数据删除的方法也有多种可以选**择根据 Id ,条件，wrapper复杂条件，批量进行数据删除。**

**物理删除： 将数据库的数据进行删除**

**逻辑删除：通过添加一个列根据列的取值觉得此数据是否存在 ，假删除 isdelete=0**

注意 设置的列名不要是一些敏感关键字如 delete....

注册逻辑删除组件

# 配置逻辑删除 mybatis-plus.global-config.db-config.logic-delete-value=1 #已删除 mybatis-plus.global-config.db-config.logic-not-delete-value=0 #未删除

测试

通过逻辑删除可以不用删除真是物理数据，方便管理员查看被删除的数据，而在数据展示中只需要增加 deleted=0 查看没有被逻辑删除的数据！

## 性能监测

MyBatisPlus也提供性能分析插件，如果超过这个时间就停止运行！

作用：性能分析拦截器，用于输出每条SQL语句及其执行时间

// SQL执行效率插件 profile环境指定为在开发阶段中才使用 @Bean @Profile({"dev","test"}) public PerformanceInterceptor performanceInterceptor(){ PerformanceInterceptor performanceInterceptor = new PerformanceInterceptor(); performanceInterceptor.setMaxTime(100); //ms 设置sql执行的最大时间，如果超过了则不执行 performanceInterceptor.setFormat(true); // 是否格式化 return performanceInterceptor; }

## 关于分页

MyBatisPlus也提供了分页的插件

// 分页插件 注册！

@Bean

public PaginationInterceptor paginationInterceptor() {

return new PaginationInterceptor();

}

**使用方式**

---

MyBatisPlusConfig

package org.app.config;

import com.baomidou.mybatisplus.core.injector.ISqlInjector;

import com.baomidou.mybatisplus.extension.injector.LogicSqlInjector;

import com.baomidou.mybatisplus.extension.plugins.OptimisticLockerInterceptor;

import com.baomidou.mybatisplus.extension.plugins.PaginationInterceptor;

import com.baomidou.mybatisplus.extension.plugins.PerformanceInterceptor;

import org.mybatis.spring.annotation.MapperScan;

import org.springframework.context.annotation.Bean;

import org.springframework.context.annotation.Configuration;

import org.springframework.context.annotation.Profile;

import org.springframework.transaction.annotation.EnableTransactionManagement;

/**

* Created with IntelliJ IDEA.

*

* @Auther: JinXu

* @Date: 2020/10/13/12:42

*/

@MapperScan("org.app.dao") //通常在 mybatis配置类进行mapper接口扫描 如果接口以@Mapper声明则省略

@EnableTransactionManagement //开启事务

@Configuration

public class MyBatisConfig {

@Bean //注册乐观锁组件

public OptimisticLockerInterceptor getOptimisticLockerInterceptor(){

System.out.println("注册了我的乐观锁组件");

return new OptimisticLockerInterceptor();

}

@Bean //注册逻辑删除

public ISqlInjector sqlInjector(){

System.out.println("注册了我的逻辑删除组件");

return new LogicSqlInjector();

}

// SQL执行效率插件

@Bean

@Profile({"dev","test"})

public PerformanceInterceptor performanceInterceptor(){

PerformanceInterceptor performanceInterceptor = new PerformanceInterceptor();

performanceInterceptor.setMaxTime(100); //ms 设置sql执行的最大时间，如果超过了则不执行

performanceInterceptor.setFormat(true); // 是否格式化

return performanceInterceptor;

}

// 分页插件

@Bean

public PaginationInterceptor paginationInterceptor() {

System.out.println("注册了我的分页组件");

return new PaginationInterceptor();

}

}

填充策略

package org.app.config;

import com.baomidou.mybatisplus.core.handlers.MetaObjectHandler;

import lombok.extern.slf4j.Slf4j;

import org.apache.ibatis.reflection.MetaObject;

import org.springframework.stereotype.Component;

import java.util.Date;

/**

* Created with IntelliJ IDEA.

*

* @Auther: JinXu

* @Date: 2020/10/13/11:48

*/

@Slf4j

@Component

public class MyMetaObjectHandler implements MetaObjectHandler {

//插入时的填充策略

@Override

public void insertFill(MetaObject metaObject) {

log.info("自动进行插入填充");

this.setFieldValByName("createdDate",new Date(),metaObject);

}

//修改时的填充策略

@Override

public void updateFill(MetaObject metaObject) {

log.info("自动进行修改填充");

this.setFieldValByName("modifyDate",new Date(),metaObject);

}

}