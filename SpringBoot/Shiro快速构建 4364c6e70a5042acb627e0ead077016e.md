# Shiro快速构建

- 导入依赖
- 配置文件
- hello world

## SpringBoot继承Shiro导入依赖

```xml
<!-- https://mvnrepository.com/artifact/org.apache.shiro/shiro-spring -->
<dependency>
    <groupId>org.apache.shiro</groupId>
    <artifactId>shiro-spring</artifactId>
    <version>1.6.0</version>
</dependency>
```

# Shiro  自定义配置 config

- 在配置三要素之前还需要初始化realm数据域   继承  AuthorzingRealm  实现父类的方法用来实现授权和认证
- 配置shiro三大核心要素   1.ShiroFilterFactoryBean   2.DefaultSecurityManager   3.Realm
- 使用倒着配置方式来配置三要素,因为上层依赖下一层

配置如下⬇️

```java
package com.sky.boot.config;

import org.apache.shiro.spring.web.ShiroFilterFactoryBean;
import org.apache.shiro.web.mgt.DefaultWebSecurityManager;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * @author Administrator
 * @Configuration 标注此类是一个配置类
 */
@Configuration
public class ShiroConfig {
    /**
     *
     * @param defaultWebSecurityManager
     * @return
     */
    @Bean
    public ShiroFilterFactoryBean getShiroFilterFactoryBean(@Qualifier(value = "WebSecurityManager") DefaultWebSecurityManager defaultWebSecurityManager) {
        ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean();
        //设置安全管理器
        shiroFilterFactoryBean.setSecurityManager(defaultWebSecurityManager);
        return shiroFilterFactoryBean;
    }

    /**
     * 将shiro安全管理器加入到ioc容器中
     *
     * @param realm
     * @return
     */
    @Bean(name = " ")
    public DefaultWebSecurityManager getDefaultWebSecurityManager(@Qualifier(value = "getRealm") Realm realm) {
        DefaultWebSecurityManager defaultWebSecurityManager = new DefaultWebSecurityManager();
//要通过默认安全管理器用户的数据,而用户的安全数据存在在realm安全领域中,需要与realm进行绑定,实现管理数据
        defaultWebSecurityManager.setRealm(realm);
        return defaultWebSecurityManager;
    }

    /**
     * 交给Spring ioc容器托管
     *
     * @return realm
     */
    @Bean
    public Realm getRealm() {
        return new Realm();
    }
}

```

## 代码解析,shiro三大对象解析

# **1.Subject（主体 the current user）**

应用代码的直接交互对象就是Subject，也就是说Shiro对外的核心API就是Subject，Subject代表了当前“用户”，这个用户不是指具体的某一个人，可以说与当前应用交互的任何东西都是Subject，与Subject的所有交互都会委托给SecurityManager来执行，可以理解为Subject只是一个充当门面的，真正的幕后老大是SecurityManager，SecurityManager才是实际的执行者。

# **2.SecurityManager（安全管理器 mananges all subjects）**

所有与安全有关的操作都会与SecurityManager进行交互，并且SecurityManager管理者所有的Subject，可以看出它才是Shiro的核心，它负责与Shiro的其他组件进行交互，它相当于SpringMvc中的dispatcherServlet（前端控制器）的角色。

# **3.Realm(领域管理 access your security data)**

Shiro从Realm获取安全数据（用户、角色、权限），就是说SecurityManager要验证用户身份，那么它需要从Realm获取相应的用户进行比较以确定用户身份是否合法，也需要从Realm获取用户的角色\权限来判断用户是否能进行一系列操作。可以把Realm看作DataSource数据源

## Subject对象

- 代表当前的用户,可以通过SecurityUtils.getSubject();方法获取当前用户对象
- 可以通过当前用户获取相对应的Session tips:此Session 并非HttpSeesion
- Subject  Session对象存值取值  使用 session.setAttribute("key","value")存值,session.getAttribute("key");取值
- 用户是否被认证  currentSubject.**isAuthenticated**();
- 设置令牌 token  ,可以通过当前的subject 的用户名和密码设置令牌   UsernamePasswordToken token=new UsernamePasswordToke("username","password");
- （坑）currentSubject.**login**(token);  执行了登录操作
- 其他方法:currentSubjecty.getPrincipal() 获取当前用户的主要信息  currentSubject.hasRole();判断是否有哪些角色  currentSubject.isPermitted();判断用户拥有的权限   currentSubject.logout();注销